{"version":3,"sources":["rules.ts"],"names":[],"mappings":"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","file":"../src/rules.js","sourcesContent":["const objectPathGet = require('object-path-get');\n\nexport namespace Rules {\n\n    interface IPropertyRule {\n        propertyName: string;\n        value?: any;\n        dateTimeValue?: string;\n    }\n\n    const testLogic = {\n        equals: (x, y) => x == y,\n        notEquals: (x, y) => x != y,\n        greaterThanOrEqualTo: (x, y) => x >= y,\n        greaterThan: (x, y) => x > y,\n        lessThanOrEqualTo: (x, y) => x <= y,\n        lessThan: (x, y) => x < y\n    }\n\n    export function evaluate(rule: any, model: any): boolean {\n        const opName = Object.keys(rule)[0];\n\n        const op = Rules[opName];\n        if (op) return op(rule[opName], model);\n\n        const func = testLogic[opName];\n        if (func) return test(rule[opName], model, func);\n\n        throw `Unsupported rule: ${opName}`;\n    }\n\n    export function all(rule: any, model: any): boolean {\n        const modelValue = objectPathGet(model, rule.propertyName);\n        let result = true;\n        for (let i = 0; result && i < modelValue.length; i++) {\n            model[rule.token] = modelValue[i];\n            result = result && evaluate(rule.predicate, model);\n        };\n        delete model[rule.token];\n        return result;\n    }\n\n    export function any(rule: any, model: any): boolean {\n        const modelValue = objectPathGet(model, rule.propertyName);\n        let result = false;\n        for (let i = 0; !result && i < modelValue.length; i++) {\n            model[rule.token] = modelValue[i];\n            result = evaluate(rule.predicate, model);\n        };\n        delete model[rule.token];\n        return result;\n    }\n\n    export function none(rule: any, model: any): boolean {\n        return !any(rule, model);\n    }\n\n    export function not(rule: any, model: any): boolean {\n        return !evaluate(rule, model);\n    }\n\n    export function and(rules: any, model: any): boolean {\n        let result = true;\n        for (let i = 0; result && i < rules.length; i++) {\n            result = result && evaluate(rules[i], model);\n        }\n        return result;\n    }\n\n    export function or(rules: any, model: any): boolean {\n        let result = false;\n        for (let i = 0; !result && i < rules.length; i++) {\n            result = evaluate(rules[i], model);\n        }\n        return result;\n    }\n\n    export function contains(rule: IPropertyRule, model: any): boolean {\n        const value = '' + (rule.value || '');\n        const modelValue = objectPathGet(model, rule.propertyName);\n        if (typeof modelValue === 'string')\n            return modelValue.indexOf(value) !== -1;\n        if (modelValue instanceof Array)\n            return (<any>modelValue).includes(value);\n        return false;\n    }\n\n    function test(rule: IPropertyRule, model: any, func: (x: any, y: any) => boolean): boolean {\n        const modelValue = objectPathGet(model, rule.propertyName);\n        if (rule.value)\n            return func(rule.value, modelValue);\n        if (rule.dateTimeValue)\n            return func(evaluateDateTime(rule.dateTimeValue), evaluateDateTime(modelValue));\n        return false;\n    }\n\n    function getModelValue(value: any, model: any): any {\n        if (value instanceof Array) return value;\n        if (value instanceof Object) {\n            return getModelValue(objectPathGet(model, value.propertyName), model);\n        }\n    }\n\n    function evaluateDateTime(dateTimeValue: any): number {\n        // todo: parse DateTimeOffset and ZonedDateTime strings\n\n        return dateTimeValue;\n    }\n}"]}